






#include     <stdio.h>
#include    <string.h>
#include  "WLcrypto.h"    //#include  "WLaes256.h"



// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
//                                                                   |
//                              AES - 256                            |
//                                                                   |
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +


//  Это ключ шифрования-дешифрации по умолчанию. На тот случай, если пользователь не выбрал другой.
//  Поменяйте байтовые значения здесь или программно проинициализируйте массив "key" другими значениями.
//  Например так: for(int i = 0; i < 32;i++) key[i] = i * 16 + i;
uint8_t        key[32] ={ 19, 111,  42, 73,   4, 115,  36, 70,  8,  79, 
                         110,  11, 212, 15, 214,  91, 160, 17, 86, 199, 
						  24,   1,  52, 93, 124, 250,  83, 27, 82,  29,
						 230,  31};


         aes256_context    ctx;   //  Структурная переменная, в которой хранится ключ шифрования и его верcии для 
                                  //  текущих операций (шифрации-дешифрации)

static   unsigned char     sz[20] = {0};

static   uint8_t  nInit  =  0 ;



//  Инициализируем структуру ctx актуальным ключом.
////////////////////////////////////////////////////////////
static void init()                                        //
{
	
	nInit = 1;
	aes256_done(&ctx);
	aes256_init(&ctx, key);                               // Инициализирует ключи: ctx->key, ctx->enckey, ctx->deckey
}







//  Места в *psz должно быть на 4 байта больше, чем занимает строка. Чтобы сохранить размер строки (4 байта)
//  Эти 4 байта добавляются в начало зашифрованного массива.
//  Только для Си-строк (оканчивающихся нулём)
// > > > > > > > > > > > > > > > > > > > > > > > > > > > > >
int WL_encAES256(char *psz)                               // 
{	                                                      
	
	 int      i = 0,                                      //  Кол-во символов в строке (длина строки)
	          x = 0,                                      //  Счётчик пакетов по 16 байт
	        pak = 0;                                      //  Количество полных пакетов по 16 байт 

	  
	 while(psz[++i]);	                                  //  Узнаём кол-во символов в строке
	 
	 if(    i  < 1)   return 0; 
	 if(nInit == 0)     init();
	 
	 
	 if(i < 17) {                                         //  Если <= 128 бит, то передаём всю строку и выходим
	 	
	    memset(sz, 0,  16);	
	 	memcpy(sz, psz, i);  aes256_encrypt_ecb(&ctx, sz); 
		
		memcpy( psz   , &i,  4);
		memcpy(&psz[4], sz, 16);           	     return i;     		                                                                                    
	 }
	 
	 pak = i / 16;                                        //  Кол-во пакетов по 128 бит (16 байт)	

	 memcpy(sz,  psz, 20);  aes256_encrypt_ecb(&ctx, sz); 	
	
	 for(x = 1; x <= pak; x++)
	 {
	 
	     memcpy(&psz[4 + (x-1)*16], sz, 16);
	 
	     sz[0] = sz[16];
	     sz[1] = sz[17];
	     sz[2] = sz[18];
	     sz[3] = sz[19];	     
	 
	     memcpy(&sz[4], &psz[4+x*16], 16); aes256_encrypt_ecb(&ctx, sz);  	     
     }
     
     memcpy(&psz[4 + (x-1)*16], sz, 16);
	 memcpy( psz ,    &i,   4);                            //  Поместим кол-во символов в начало зашифрованного пакета
	
return i; 	
}



//  Места в *psz должно быть на 4 байта больше, чем занимает распакованная строка.
//  Только для Си-строк (оканчивающихся нулём)
//  <-  <-  <-  <-  <-  <-  <-  <-  <-  <-  <-  <-  <-  <-  
int WL_AES256dec(char *psz)                              // 
{

	 int   i    ,                                    // Узнаём кол-во символов в строке
	       x = 0, 
		 pak = 0;                                    //  Счётчик пакетов по 16 байт
	
	 memcpy(&i, psz, 4);
	 
	 if(    i  < 1)  return 0; 
     if(nInit == 0)    init();
	 
	 if(i < 17)                                //  Если <= 128 бит (меньше 17 байт), то передаём всю строку и выходим
	 {	                                                                                         //memset(sz, 0,  16);	 	  	 
	    memcpy( sz, &psz[4], 16);               aes256_decrypt_ecb(&ctx, sz);	   	    	    	
	    memcpy(psz,   sz,     i);   
		psz[i] = 0;    return i ; 
     }

     pak = i/16;  if(i%16) pak ++; 
                                                                                        //  printf("pak = %d\n", pak);
	 for(x = 0; x < pak; x++)
	 {	 	                                                                                    // memset(sz, 0,  16);	 	
	 	 memcpy(  sz, &psz[4 + x * 16], 16);    aes256_decrypt_ecb(&ctx, sz);
	 	 memcpy(&psz[x * 16], sz,  16); 
	 }

     psz[i] = 0; 

return i; 	
}













// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
//                                                                   |
//                              SHA - 256                            |
//                                                                   |
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +



static unsigned __int8   hv[32];  

/////////////////////////////////////////////////////////////////////////////////   //  uint8_t hv[32];
uint8_t* WL_sha256(const char* sz, int len)                                    //   //  uint8_t hv[32];	
{
	
      sha256_context ctx;
      sha256_init(  &ctx);
      sha256_hash(  &ctx, (uint8_t *)sz, (uint32_t)len);
      sha256_done(  &ctx, hv); 

return  hv;
}






// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
//                                                                   |
//                    Функции тестирования:                          |
//                                                                   |
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +


int i;


//  Печатает в консоли строку - побайтовое содержимое буфера
//  Примеры ниже:
//  enc: 8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89    (  dump("enc: ", buf, sizeof(buf)); )
//  tst: 8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89  
//  dec: 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
////////////////////////////////////////////////////////////
void dump(const char *s, uint8_t *buf, int size)          //
{ 
	 printf(s);                   
	
     for(i = 0; i < (size); i++) 
	 { 
	     printf("%02x ", buf[i]); 
	 }   printf("\n"); 
}



//  Печатает без пробелов
////////////////////////////////////////////////////////////
void dump1(const char *s, uint8_t *buf, int size)         //
{ 
	 printf(s);                   
	
     for(i = 0; i < (size); i++) 
	 { 
	     printf("%02x", buf[i]); 
	 }   printf("\n"); 
}

























